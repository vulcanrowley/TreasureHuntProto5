import Room from "./room";
import TILES, { DebugTileMap } from "./tiles";
import { DebugHtmlConfig, DebugConsoleConfig } from "./debug";
import Point from "./point";
declare type DimensionConfig = {
    min: number;
    max: number;
    onlyOdd?: boolean;
    onlyEven?: boolean;
};
declare type RoomConfig = {
    width: DimensionConfig;
    height: DimensionConfig;
    maxArea?: number;
    maxRooms?: number;
};
export declare type DungeonConfig = {
    width: number;
    height: number;
    randomSeed?: string;
    doorPadding?: number;
    rooms: RoomConfig;
};
export default class Dungeon {
    height: number;
    width: number;
    tiles: TILES[][];
    rooms: Room[];
    private doorPadding;
    private r;
    roomGrid: Room[][][];
    private maxRooms;
    private maxRoomArea;
    private roomWidthConfig;
    private roomHeightConfig;
    private randomSeed?;
    constructor(config: DungeonConfig);
    /**
     * Adjust the given dimension config for parity settings (onlyOdd, onlyEven) so that min/max are
     * adjusted to reflect actual possible values.
     * @param dimensionConfig
     */
    private adjustDimensionConfigForParity;
    private checkDimensionConfig;
    getConfig(): DungeonConfig;
    drawToConsole(config: DebugConsoleConfig): void;
    drawToHtml(config: DebugHtmlConfig): DocumentFragment;
    getMappedTiles(tileMapping?: DebugTileMap): (string | number | undefined)[][];
    getCenter(): Point;
    generate(): void;
    hasRoomAt(x: number, y: number): boolean;
    getRoomAt(x: number, y: number): Room | null;
    /**
     * Attempt to add a room and return true/false based on whether it was successful.
     * @param room
     */
    private addRoom;
    private canFitRoom;
    private createRandomRoom;
    private generateRoom;
    getTiles(): TILES[][];
    private getPotentiallyTouchingRooms;
    private findNewDoorLocation;
    private findRoomAttachment;
    private addDoor;
}
export {};
